"""___package_name___ root Conan file"""

from importlib import import_module
import os
from typing import List, Dict

from conan import ConanFile
from conan.errors import ConanException
from conan.tools.files import copy as copy_file
from conan.tools.gnu import PkgConfigDeps
from conan.tools.gnu.pkgconfigdeps import _PCGenerator
from conan.tools.meson import Meson, MesonToolchain
from conan.tools.scm import Git


this_dir: str = os.path.dirname(__file__)

required_conan_version = ">=2.3.0"


class ___package_name___(ConanFile):
    """___package_name___"""

    # Required
    name = "___package_name___"

    # Metadata
    license = "___license___"
    author = "___author___ (___email___)"
    url = "___url___"
    description = "___description___"
    topics = ["<< topics >>"]

    # Configuration
    package_type = "___package_type___"
    settings = "os", "compiler", "build_type", "arch"
    options = {
        "shared": [True, False],
        "fPIC": [True, False],
        "quit_after_generate": [True, False],
    }
    default_options = {
        "shared": False,
        "fPIC": True,
        "quit_after_generate": False,
    }
    build_policy = "missing"

    # Files needed by Conan to resolve version and dependencies
    exports = (
        os.path.join(".git", "*"),
        "update_deps.py",
        "binary_config.json",
    )

    # Files needed by Conan to build from source
    exports_sources = (
        os.path.join("build_scripts", "*"),
        os.path.join(name, "*"),
        os.path.join("src", "*"),
        "meson.build",
    )

    # External includes
    _binary_config_module = import_module("update_deps")

    def set_version(self):
        """Get project version from Git"""
        git = Git(self, folder=self.recipe_folder)
        try:
            self.version = git.run("describe --tags").partition("-")[0]
        except ConanException:
            self.version = "0.0.0"

    def config_options(self):
        """Change available options"""
        if self.settings.os == "Windows":
            del self.options.fPIC

    def configure(self):
        """Change behavior based on set options"""
        if self.options.shared:
            self.options.rm_safe("fPIC")

    def build_requirements(self):
        """Declare dependencies of the build system"""
        self.tool_requires("meson/1.4.0")
        self.tool_requires("pkgconf/2.2.0")

    def requirements(self):
        """Resolve and declare dependencies"""
        self._binaries = self._binary_config_module.Binaries()
        self._binaries.read()

        for binary in self._binaries:
            for dep in binary.dependencies:
                # Ignore deactivated dependencies
                if not dep.enabled:
                    continue

                # Declare dependencies
                if not dep.link_preference:
                    self.requires(dep.name + "/" + dep.version)
                else:
                    self.requires(
                        dep.name + "/" + dep.version,
                        options={"shared": dep.dynamic},
                    )

    def layout(self):
        """Set the layout of the build files"""
        self.folders.build = os.path.join(self.recipe_folder, "build")
        self.folders.generators = os.path.join(self.folders.build, "generators")

    def generate(self):
        """Generate the build system"""
        # Generate .pc files for dependencies
        deps = PkgConfigDeps(self)
        deps.generate()

        # Resolve dependency components
        # dependencies: Dict[str, Dict[str, Component]] = {}
        # dependencies: Dict["dep_name_and_version", Dict["component_name", Component]] = {}
        resolved_dependencies = {}
        for require, dep in self.dependencies.host.items():
            # Name and version of the dependency
            dependency_name_and_version: str = (
                dep.ref.name + "/" + str(dep.ref.version)
            )

            # Create a dictionary for storing components of this dependency
            if dependency_name_and_version not in resolved_dependencies:
                resolved_dependencies[dependency_name_and_version] = {}

            # This class is used internally by Conan to get dependency component information and generate PkgConfig files
            pc_generator = _PCGenerator(deps, require, dep)

            # Add the name of the package as the sole component if it does not have any components
            if not pc_generator._dep.cpp_info.has_components:
                sole_component_name: str = pc_generator._package_info().name
                resolved_dependencies[dependency_name_and_version][
                    sole_component_name
                ] = self._binary_config_module.Component(
                    name=sole_component_name,
                    enabled=True,
                )

            # Accumulate all components of the dependency
            for component_info in pc_generator._components_info():
                component_name: str = component_info.name
                resolved_dependencies[dependency_name_and_version][
                    component_name
                ] = self._binary_config_module.Component(
                    name=component_name,
                    enabled=True,
                )

        # declared_binaries: Dict[
        #     str,
        #     Dict[
        #         str,
        #         Dict[str, Dict[str, Dict[str, bool] | bool | None]]
        #         | List[List[str]]
        #         | List[str]
        #         | str,
        #     ],
        # ]
        declared_binaries: dict = self._binaries.json()

        # Merge resolved dependency components with dependency components explicitly declared within the binary configuration.
        for binary, binary_info in declared_binaries.items():
            for dep_name_and_version, dep_info in binary_info[
                "dependencies"
            ].items():

                # Remove components from the list of declared components that do not exist within the resolved components list
                for component_name, component in dep_info["components"].items():
                    if (
                        component_name
                        in resolved_dependencies[dep_name_and_version]
                    ):
                        continue
                    dep_info["components"].pop(component_name)
                    # declared_binaries[binary]["dependencies"][dep_name_and_version]["components"].pop(component_name)

                # Add missing components to the list of declared components
                if dep_name_and_version not in resolved_dependencies:
                    continue
                for component_name, component in resolved_dependencies[
                    dep_name_and_version
                ].items():
                    if component_name in dep_info["components"]:
                        continue
                    # Add missing component to dep_info
                    dep_info["components"][component_name] = component.enabled
                    # declared_binaries[binary]["dependencies"][dep_name_and_version]["components"].pop(component_name)

        self._binaries.structured(declared_binaries)
        self._binaries.write()

        toolchain = MesonToolchain(self)
        toolchain.properties = {
            "_name": self.name,
            "_version": self.version,
            "_binaries": self._binaries.unstructured(),
        }
        toolchain.generate()

        if self.options.quit_after_generate:
            exit(0)

    def build(self):
        """Build this project"""
        self._build_folder = os.path.join(self.recipe_folder, "build")
        meson = Meson(self)
        meson.configure()
        meson.build()
        copy_file(
            self,
            "compile_commands.json",
            self.build_folder,
            self.source_folder,
        )
        meson.test()

    def package(self):
        """Install project headers and compiled binaries"""
        meson = Meson(self)
        meson.install()

    def package_info(self):
        """Package information"""
        self.cpp_info.libs = [self.name]
        self.cpp_info.includedirs = ["include"]
        self.cpp_info.bindirs = ["bin"]
