"""___package_name___ root Conan file"""

from importlib import import_module
import os
from typing import List, Dict

from conan import ConanFile
from conan.errors import ConanException
from conan.tools.files import copy as copy_file
from conan.tools.gnu import PkgConfigDeps
from conan.tools.gnu.pkgconfigdeps import _PCGenerator
from conan.tools.meson import Meson, MesonToolchain
from conan.tools.scm import Git


this_dir: str = os.path.dirname(__file__)

required_conan_version = ">=2.0.0"


class ___package_name___(ConanFile):
    """___package_name___"""

    # Required
    name = "___package_name___"

    # Metadata
    license = "___license___"
    author = "___author___ (___email___)"
    url = "___url___"
    description = "___description___"
    topics = ["<< topics >>"]

    # Configuration
    package_type = "___package_type___"
    settings = "os", "compiler", "build_type", "arch"
    options = {
        "quit_after_generate": [True, False],
    }
    default_options = {
        "quit_after_generate": False,
    }
    build_policy = "missing"

    # Files needed by Conan to resolve version and dependencies
    exports = (
        os.path.join(".git", "*"),
        "update_deps.py",
        "binary_config.json",
    )

    # Files needed by Conan to build from source
    exports_sources = (
        os.path.join("src", "*"),
        "meson.build",
    )

    # External includes
    _binary_config_module = import_module("update_deps")

    def set_version(self):
        """Get project version from Git"""
        git = Git(self, folder=self.recipe_folder)
        try:
            self.version = git.run("describe --tags").partition("-")[0]
        except ConanException:
            self.version = "0.0.0"

    def build_requirements(self):
        """Declare dependencies of the build system"""
        self.tool_requires("meson/1.4.0")
        self.tool_requires("pkgconf/2.2.0")

    def requirements(self):
        """Resolve and declare dependencies"""
        self._binaries = self._binary_config_module.Binaries()
        self._binaries.read()

        for binary in self._binaries:
            for dep in binary.dependencies:
                # Ignore deactivated dependencies
                if not dep.enabled:
                    continue

                # Declare dependencies
                if not dep.link_preference:
                    self.requires(dep.name + "/" + dep.version)
                else:
                    self.requires(
                        dep.name + "/" + dep.version,
                        options={"shared": dep.dynamic},
                    )

    def layout(self):
        """Set the layout of the build files"""
        self.folders.build = os.path.join(self.recipe_folder, "build")
        self.folders.generators = os.path.join(self.folders.build, "generators")

    def generate(self):
        """Generate the build system"""
        # Generate .pc files for dependencies
        deps = PkgConfigDeps(self)
        deps.generate()

        # Resolve dependency components
        # dependencies: Dict[str, Dict[str, Component]] = {}
        # dependencies: Dict["dep_name_and_version", Dict["component_name", Component]] = {}
        resolved_dependencies = {}
        for require, dep in self.dependencies.host.items():
            pc_generator = _PCGenerator(deps, require, dep)
            # TODO: Ensure that dependencies without any components are included in the implicit dependency list.
            for component_info in pc_generator._components_info():
                component_name: str = component_info.name
                component_version: str = str(dep.ref.version)
                dependency_name: str = dep.ref.name + "/" + component_version
                if dependency_name not in resolved_dependencies:
                    resolved_dependencies[dependency_name] = {}
                resolved_dependencies[dependency_name][component_name] = (
                    self._binary_config_module.Component(
                        name=component_name,
                        enabled=True,
                    )
                )

        # declared_binaries: Dict[
        #     str,
        #     Dict[
        #         str,
        #         Dict[str, Dict[str, Dict[str, bool] | bool | None]]
        #         | List[List[str]]
        #         | List[str]
        #         | str,
        #     ],
        # ]
        declared_binaries: dict = self._binaries.json()

        # Merge resolved dependency components with dependency components explicitly declared within the binary configuration.
        for binary, binary_info in declared_binaries.items():
            for dep_name_and_version, dep_info in binary_info[
                "dependencies"
            ].items():

                # Remove components from the list of declared components that do not exist within the resolved components list
                for component_name, component in dep_info["components"].items():
                    if dep_name_and_version not in resolved_dependencies:
                        continue
                    if (
                        component_name
                        in resolved_dependencies[dep_name_and_version]
                    ):
                        continue
                    dep_info["components"].pop(component_name)
                    # declared_binaries[binary]["dependencies"][dep_name_and_version]["components"].pop(component_name)

                # Add missing components to the list of declared components
                if dep_name_and_version not in resolved_dependencies:
                    continue
                for component_name, component in resolved_dependencies[
                    dep_name_and_version
                ].items():
                    if component_name in dep_info["components"]:
                        continue
                    # Add missing component to dep_info
                    dep_info["components"][component_name] = component.enabled
                    # declared_binaries[binary]["dependencies"][dep_name_and_version]["components"].pop(component_name)

        self._binaries.structured(declared_binaries)
        self._binaries.write()

        toolchain = MesonToolchain(self)
        toolchain.properties = {
            "_name": self.name,
            "_version": self.version,
            "_binaries": self._binaries.unstructured(),
        }
        toolchain.generate()

        if self.options.quit_after_generate:
            exit(0)

    def build(self):
        """Build this project"""
        self._build_folder = os.path.join(self.recipe_folder, "build")
        meson = Meson(self)
        meson.configure()
        copy_file(
            self,
            "version.hpp",
            self.build_folder,
            self.source_folder + "/___version_header_dir___/",
        )
        meson.build()
        copy_file(
            self,
            "compile_commands.json",
            self.build_folder,
            self.source_folder,
        )
        meson.test()
